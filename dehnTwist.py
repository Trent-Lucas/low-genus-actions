

# This file was *autogenerated* from the file dehnTwist.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3)
from homology import *

#Helper function: takes in two edges on the same sheet (g,i) and (g,j) and returns list of oriented edges (g, k, direction) between their inital vertices going clockwise
def edges_between(edge1, edge2, number_of_edges, edge_orientations):
    g = edge1[_sage_const_0 ]
    if edge2[_sage_const_0 ] != g:
        raise ValueError("Edges must lie on the same sheet")

    fullEdgesBetween = (edge2[_sage_const_1 ] - edge1[_sage_const_1 ]) % number_of_edges

    edges = []
    if edge_orientations[edge1[_sage_const_1 ]] == _sage_const_1 :
        edges.append((g,edge1[_sage_const_1 ],_sage_const_1 ))
    for i in range(edge1[_sage_const_1 ]+_sage_const_1 , edge1[_sage_const_1 ] + fullEdgesBetween):
        edges.append((g, i % number_of_edges, _sage_const_1 ))
    if edge_orientations[edge2[_sage_const_1 ]] == -_sage_const_1 :
        edges.append((g,edge2[_sage_const_1 ],_sage_const_1 ))
    
    return edges


# Input:
#   G is a finite group
#   hom is a list of elements of G 
#   downstairs curve is a list of 3-tuples (i, position, orientation) where i is the edge label, indicates how close the intersecting arc is to 
#       the initial vertex (0 is closest), orientation is an element of [1,-1] indicating whether the arc is entering or exiting
#   e is an edge (g,i)
#   power is an integer
# Output: A list of tuples (g, i, direction) where direction is 1 if edge is traversed clockwise, -1 if edge is traversed counterclockwise
#
# Idea: 

def action_of_dehn_twist_on_edge(G, number_of_edges, hom, gluing, edge_orientations, downstairs_curve, e, power):
    liftToIdentitySheet = []
    currentSheet = G.identity()
    for edge in downstairs_curve:
        liftToIdentitySheet.append((currentSheet, edge[_sage_const_0 ], edge[_sage_const_1 ], edge[_sage_const_2 ]))
        if edge[_sage_const_2 ] == -_sage_const_1 :
            continue
        else:
            currentSheet = currentSheet * hom[edge[_sage_const_0 ]]
    deckTransformation = currentSheet

    initialLift = [edge for edge in liftToIdentitySheet]
    for i in range(_sage_const_1 , deckTransformation.order()):
        for edge in initialLift:
            liftToIdentitySheet.append((deckTransformation**(i) * edge[_sage_const_0 ], edge[_sage_const_1 ], edge[_sage_const_2 ], edge[_sage_const_3 ]))

    transveral = [coset[_sage_const_0 ] for coset in G.cosets(G.subgroup([deckTransformation]), side='left')]
    lifts = [[(r*edge[_sage_const_0 ], edge[_sage_const_1 ], edge[_sage_const_2 ], edge[_sage_const_3 ]) for edge in liftToIdentitySheet] for r in transveral]

    #intersections_with_e is a list of pairs (i,j) where lifts[i][j] == e
    intersections_with_e = []
    for i in range(_sage_const_0 , len(lifts)):
        for j in range(_sage_const_0 , len(lifts[i])):
            edge = lifts[i][j]
            if (edge[_sage_const_0 ], edge[_sage_const_1 ]) == (e[_sage_const_0 ],e[_sage_const_1 ]):
                intersections_with_e.append((i, j))
    #we sort intersections_with_e by position
    intersections_with_e.sort(key=(lambda pair : lifts[pair[_sage_const_0 ]][pair[_sage_const_1 ]][_sage_const_2 ]))

    if len(intersections_with_e) == _sage_const_0 :
        # To figure out "correcion" deck transformation, need to find out which component the initial vertex of e lies on 
        # Enough to figure out which lift is "closest" as you move clockwise around the boundary 
        
        if edge_orientations[(e[_sage_const_1 ] - _sage_const_1 ) % number_of_edges] == _sage_const_1 :
            closestEdge = (e[_sage_const_0 ], (e[_sage_const_1 ] - _sage_const_1 ) % number_of_edges, float('inf'), _sage_const_1 )
        else:
            closestEdge = (e[_sage_const_0 ], (e[_sage_const_1 ] - _sage_const_1 ) % number_of_edges, _sage_const_0 , _sage_const_1 )

        for i in range(_sage_const_0 , len(lifts)):
            for j in range(_sage_const_0 , len(lifts[i])):
                edge = lifts[i][j]
                if edge[_sage_const_0 ] == e[_sage_const_0 ]:
                    if ((edge[_sage_const_1 ] - e[_sage_const_1 ]) % number_of_edges) < ((closestEdge[_sage_const_1 ] - e[_sage_const_1 ]) % number_of_edges):
                        closestPair = [i,j]
                        closestEdge = (edge[_sage_const_0 ],edge[_sage_const_1 ],edge[_sage_const_2 ],edge[_sage_const_3 ])
                    
                    if ((edge[_sage_const_1 ] - e[_sage_const_1 ]) % number_of_edges) == ((closestEdge[_sage_const_1 ] - e[_sage_const_1 ]) % number_of_edges):
                        if edge_orientations[edge[_sage_const_1 ]] == _sage_const_1  and edge[_sage_const_3 ] <= closestEdge[_sage_const_3 ]:
                            closestPair = [i,j]
                            closestEdge = (edge[_sage_const_0 ], edge[_sage_const_1 ], edge[_sage_const_2 ], edge[_sage_const_3 ])
                        elif edge_orientations[edge[_sage_const_1 ]] == -_sage_const_1  and edge[_sage_const_3 ] >= closestEdge[_sage_const_3 ]:
                            closestPair = [i,j]
                            closestEdge = (edge[_sage_const_0 ], edge[_sage_const_1 ], edge[_sage_const_2 ], edge[_sage_const_3 ])

        if lifts[closestPair[_sage_const_0 ]][closestPair[_sage_const_1 ]][_sage_const_3 ] == _sage_const_1 :
            correctionDeckTransformation = G.identity()
        else:
            correctionDeckTransformation = transveral[closestPair[_sage_const_0 ]]*deckTransformation*transveral[closestPair[_sage_const_0 ]]**(-_sage_const_1 )

        return [((correctionDeckTransformation**power)*e[_sage_const_0 ],e[_sage_const_1 ],edge_orientations[e[_sage_const_1 ]])]
    
    else:
        newEdges = []
        offset = _sage_const_0  #keeps track of total deck transformation accumulated so far

        # To figure out "correction" deck transformation, need to determine the deck transformation for the component of initial vertex
        # Assumption: we fix the component to the left of lifts[0]
        # Given this, you just need to figure out if you're to the left or right of lifts[intersections_with_e[0][0]]
        firstPair = intersections_with_e[_sage_const_0 ]
        if edge_orientations[e[_sage_const_1 ]]*lifts[firstPair[_sage_const_0 ]][firstPair[_sage_const_1 ]][_sage_const_3 ] == _sage_const_1 :
            correctionDeckTransformation = G.identity()
        else:
            correctionDeckTransformation = transveral[firstPair[_sage_const_0 ]]*deckTransformation*transveral[firstPair[_sage_const_0 ]]**(-_sage_const_1 )

        if edge_orientations[e[_sage_const_1 ]] == _sage_const_1 :
            for pair in intersections_with_e:
                givenLift = lifts[pair[_sage_const_0 ]]
                orientation = givenLift[pair[_sage_const_1 ]][_sage_const_3 ]
                index = (pair[_sage_const_1 ] + offset*len(initialLift)*orientation) % len(givenLift)
                currentSheet = givenLift[index][_sage_const_0 ]
                enteringEdge = (givenLift[index][_sage_const_0 ], givenLift[index][_sage_const_1 ])
                offset = offset + power

                for i in range(_sage_const_0 , (len(initialLift)/_sage_const_2 )*power):
                    currentSheet = currentSheet * hom[enteringEdge[_sage_const_1 ]]
                    index = (index + (_sage_const_2 *orientation)) % len(givenLift)
                    exitingEdge = (currentSheet, gluing[enteringEdge[_sage_const_1 ]])
                    enteringEdge = (givenLift[index][_sage_const_0 ], givenLift[index][_sage_const_1 ])
                    
                    newEdges = newEdges + edges_between(exitingEdge, enteringEdge, number_of_edges, edge_orientations)
            newEdges.append((currentSheet, e[_sage_const_1 ], _sage_const_1 ))

            return [((correctionDeckTransformation**power)*edge[_sage_const_0 ],edge[_sage_const_1 ],edge[_sage_const_2 ]) for edge in newEdges]

        if edge_orientations[e[_sage_const_1 ]] == -_sage_const_1 :
            for pair in intersections_with_e:
                givenLift = lifts[pair[_sage_const_0 ]]
                orientation = -givenLift[pair[_sage_const_1 ]][_sage_const_3 ] #will pick up positive power of deck transform if givenLift is leaving this edge
                index = (pair[_sage_const_1 ] + offset*len(initialLift)*orientation) % len(givenLift)
                currentSheet = givenLift[index][_sage_const_0 ]
                exitingEdge = (givenLift[index][_sage_const_0 ], givenLift[index][_sage_const_1 ])
                offset = offset + power

                index = (index + orientation) % len(givenLift)
                enteringEdge = (givenLift[index][_sage_const_0 ],givenLift[index][_sage_const_1 ])
                newEdges = newEdges + edges_between(exitingEdge, enteringEdge, number_of_edges, edge_orientations)                

                for i in range(_sage_const_0 , ((len(initialLift)/_sage_const_2 )*power) - _sage_const_1 ):
                    currentSheet = currentSheet * hom[enteringEdge[_sage_const_1 ]]
                    index = (index + (_sage_const_2 *orientation)) % len(givenLift)
                    exitingEdge = (currentSheet, gluing[enteringEdge[_sage_const_1 ]])
                    enteringEdge = (givenLift[index][_sage_const_0 ], givenLift[index][_sage_const_1 ])
                    
                    newEdges = newEdges + edges_between(exitingEdge, enteringEdge, number_of_edges, edge_orientations)
            
            currentSheet = currentSheet * hom[enteringEdge[_sage_const_1 ]]
            newEdges.append((currentSheet, e[_sage_const_1 ], -_sage_const_1 ))

            return [((correctionDeckTransformation**power)*edge[_sage_const_0 ],edge[_sage_const_1 ], edge[_sage_const_2 ]) for edge in newEdges]


def action_of_dehn_twist_on_edge_module(G, number_of_edges, hom, gluing, downstairs_curve, edge_module, edge_orientations,power):
    edgeLabel = lambda e : list(edge_module.basisLabels.keys())[list(edge_module.basisLabels.values()).index(e)]
    actionOnEdges = linear_transformation(
        edge_module.module, 
        edge_module.module,
        lambda e : edge_module.module.sum([edge_module.basisLabels[(edge[_sage_const_0 ],edge[_sage_const_1 ])]*edge[_sage_const_2 ]*edge_orientations[edge[_sage_const_1 ]] for edge in action_of_dehn_twist_on_edge(G, number_of_edges, hom, gluing, edge_orientations, downstairs_curve, edgeLabel(e),power)])
    )
    return actionOnEdges


def action_of_dehn_twist_on_chain_group(G, number_of_edges, hom, gluing, downstairs_curve, edge_chain_group, edge_orientations,power):
    T = action_of_dehn_twist_on_edge_module(G, number_of_edges, hom, gluing, downstairs_curve, edge_chain_group.edge_module, edge_orientations,power)
    actionOnChainGroup = linear_transformation(
        edge_chain_group.module, 
        edge_chain_group.module,
        lambda e : edge_chain_group.module.quotient_map()(T(edge_chain_group.module.lift_map()(e)))
    )
    return actionOnChainGroup

def action_of_dehn_twist_on_homology(G, number_of_edges, hom, gluing, downstairs_curve, homology, edge_orientations,power):
    T = action_of_dehn_twist_on_chain_group(G, number_of_edges, hom, gluing, downstairs_curve, homology.edge_chain_group, edge_orientations,power)
    actionOnHomology = linear_transformation(
        homology.module, 
        homology.module,
        lambda x : homology.module.quotient_map()(T(homology.module.lift_map()(x)))
    )
    return actionOnHomology

###Testing###

#G = SymmetricGroup(4)
#x = G("(1,2)"); y = G("(2,3)"); z = G("(3,4)"); u = G("(1,3)"); v = G("(1,4)"); w = G("(2,4)")
#number_of_edges = 6
#hom = [x,x, y, y, y*x*z*y, y*x*z*y]
#gluing = {0:1, 1:0, 2:3, 3:2, 4:5, 5:4}
#edge_orientations = {0:1,1:-1,2:1,3:-1,4:1,5:-1}

#print(action_of_dehn_twist_on_edge(G, number_of_edges, hom, gluing, edge_orientations, [(5,0,1), (4,0,-1), (1,0,1), (0,0,-1)], (G.identity(),4), 1))
#print(action_of_dehn_twist_on_edge(G, number_of_edges, hom, gluing, edge_orientations, [(5,0,1), (4,0,-1), (1,0,1), (0,0,-1)], (G.identity(),5), 1))

#h = HomologyGroup(G, number_of_edges, gluing, hom, edge_orientations)

#T = action_of_dehn_twist_on_homology(G, number_of_edges, hom, gluing, [(0,0,1), (1,0,-1), (4,0,1), (5,0,-1)], h, edge_orientations, 1)

