

# This file was *autogenerated* from the file 3-ad-2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0)#############################################################################
#
# In this file, we show that H_1(S) is a 4-dimensional irrep together with two 1-dimensional irreps
#
#############################################################################

from surfaces import *
from lifted_twist import *
from index import *

G = PermutationGroup([[(_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ),(_sage_const_5 ,_sage_const_6 ,_sage_const_7 ,_sage_const_8 )], [(_sage_const_1 ,_sage_const_4 ,_sage_const_3 ,_sage_const_2 ),(_sage_const_5 ,_sage_const_6 ,_sage_const_7 ,_sage_const_8 )], [(_sage_const_1 ,_sage_const_6 ),(_sage_const_2 ,_sage_const_7 ),(_sage_const_3 ,_sage_const_8 ),(_sage_const_4 ,_sage_const_5 )]])
alpha = G.gens()[_sage_const_0 ]; r = G.gens()[_sage_const_1 ]; s = G.gens()[_sage_const_2 ]
x = s; y = s*r; z = alpha
number_of_edges = _sage_const_6 
hom = [x,x**(-_sage_const_1 ), x*z*y, (x*z*y)**(-_sage_const_1 ), y, y**(-_sage_const_1 )]
gluing = {_sage_const_0 :_sage_const_1 , _sage_const_1 :_sage_const_0 , _sage_const_2 :_sage_const_3 , _sage_const_3 :_sage_const_2 , _sage_const_4 :_sage_const_5 , _sage_const_5 :_sage_const_4 }
edge_orientations = {_sage_const_0 :_sage_const_1 ,_sage_const_1 :-_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :-_sage_const_1 ,_sage_const_4 :_sage_const_1 ,_sage_const_5 :-_sage_const_1 }

base_surface = BaseSurface(number_of_edges, gluing, edge_orientations)
cover = Cover(base_surface, G, hom)

homology = HomologyGroup(cover)
deck_group_actions = {g:homology.action_of_deck_group_on_homology(g).matrix().transpose() for g in G}
# Sage assumes matrices act on the right, so we take the transpose to get an actual homomorphism
for g in G:
    for h in G:
        assert deck_group_actions[g]*deck_group_actions[h] == deck_group_actions[g*h]
assert homology.module.dimension() == _sage_const_6 


##### Building the irreps #####

big_rep = {alpha: matrix([[_sage_const_0 ,-_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ]]),
    r: matrix([[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ]]),
    s: matrix([[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ]])}

small_rep = {alpha: -_sage_const_1 , r: _sage_const_1 , s: -_sage_const_1 }

for i in range(_sage_const_0 ,_sage_const_2 ):
    for j in range(_sage_const_0 ,_sage_const_2 ):
        for k in range(_sage_const_0 , _sage_const_4 ):
            big_rep[alpha**i*s**j*r**k] = big_rep[alpha]**i*big_rep[s]**j*big_rep[r]**k
            small_rep[alpha**i*s**j*r**k] = small_rep[alpha]**i*small_rep[s]**j*small_rep[r]**k


##### Verifications #####

# First, we check that we have the right representation
for g in G.list():
    assert deck_group_actions[g].trace() == _sage_const_2 *small_rep[g] + big_rep[g].trace()

# Next, we can check that our big_rep is indeed a surjection onto M_2(Q(i))
mat_to_vec = lambda m : vector([m[i][j] for i in range(_sage_const_0 ,_sage_const_4 ) for j in range(_sage_const_0 ,_sage_const_4 )])
vectors = [mat_to_vec(big_rep[g]) for g in G.list()]
assert dim(span(vectors, QQ)) == _sage_const_8 

