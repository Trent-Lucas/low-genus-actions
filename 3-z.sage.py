

# This file was *autogenerated* from the file 3-z.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_6 = Integer(6); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5)#############################################################################
#
# In this file, we show that H_1(S) is two copies of the standard rep, and that
# that the action is arithmetic.
#
#############################################################################

from surfaces import *
from lifted_twist import *
from index import *

G = AlternatingGroup(_sage_const_4 )
x = G("(1,2)(3,4)"); y = G("(1,2,3)")
number_of_edges = _sage_const_6 
hom = [x,x,x,x,y,y**(-_sage_const_1 )]
gluing = {_sage_const_0 :_sage_const_1 ,_sage_const_1 :_sage_const_0 ,_sage_const_2 :_sage_const_3 ,_sage_const_3 :_sage_const_2 ,_sage_const_4 :_sage_const_5 ,_sage_const_5 :_sage_const_4 }
edge_orientations = {_sage_const_0 :_sage_const_1 ,_sage_const_1 :-_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :-_sage_const_1 ,_sage_const_4 :_sage_const_1 ,_sage_const_5 :-_sage_const_1 }

base_surface = BaseSurface(number_of_edges, gluing, edge_orientations)
cover = Cover(base_surface, G, hom)

homology = HomologyGroup(cover)
deck_group_actions = {g:homology.action_of_deck_group_on_homology(g).matrix().transpose() for g in G}
# Sage assumes matrices act on the right, so we take the transpose to get an actual homomorphism
for g in G:
    for h in G:
        assert deck_group_actions[g]*deck_group_actions[h] == deck_group_actions[g*h]
assert homology.module.dimension() == _sage_const_6 

##### Building the irrep #####

# Our isotypic component is 2 copies of the standard representation of A_4
# In this case, the isotypic component is the entire homology group
# We want an orthogonal representation with integer entries, so we build it by hand.

H = SymmetricGroup(_sage_const_4 )
a = H("(1,2)"); b = H("(2,3)"); c = H("(3,4)"); d = H("(1,3)"); e = H("(1,4)"); f = H("(2,4)")

# First, we define the representation on the transpositions
rep = {a: matrix([[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]]), b: matrix([[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[-_sage_const_1 ,_sage_const_0 ,_sage_const_0 ]]), c: matrix([[_sage_const_0 ,-_sage_const_1 ,_sage_const_0 ],[-_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]]),
    d: matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ],[_sage_const_0 ,-_sage_const_1 ,_sage_const_0 ]]), e: matrix([[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ]]), f: matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ]])}

# Next, given an arbitrary permutation, we wish to decompose it into transpositions
def transposition_decomp(g):
    transposition_tuples = []
    for t in g.cycle_tuples():
        for i in range(_sage_const_0 , len(t) - _sage_const_1 ):
            transposition_tuples.append((t[i], t[i+_sage_const_1 ]))
    
    # We can check that our decomposition is correct
    product = H.identity()
    for transposition in transposition_tuples:
        product = H(transposition)*product
    assert product == g

    return transposition_tuples

# Now, we can build our representation
def get_rep(g):
    transpositions = transposition_decomp(g)
    image = matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
    for transposition in transpositions:
        image = rep[H(transposition)]*image
    return image

# To minimize computation, we store the representation in a dictionary
for g in H.list():
    rep[g] = get_rep(g)

# Checking that we have the correct representation
for g in G:
    assert deck_group_actions[g].trace() == _sage_const_2 *rep[g].trace()

##### Building isomorphism between homology and rep #####

A = matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
assert A.determinant() != _sage_const_0 
B = zero_matrix(_sage_const_6 )

for g in G:
    g_bad = deck_group_actions[g]
    g_good = block_diagonal_matrix(rep[g], rep[g])
    B = B + g_bad*A*(g_good.inverse())

# Checking that we indeed have an isomorphism
assert B.determinant() != _sage_const_0 
for g in G:
    g_bad = deck_group_actions[g]
    g_good = block_diagonal_matrix(rep[g], rep[g])
    assert g_bad*B*(g_good.inverse()) == B

##### Lifting twists #####

twist_matrices = []

for power in range (_sage_const_1 ,_sage_const_4 ):
    for curve in liftable_curves(cover, power):
        T = action_of_twist_on_homology(cover, homology, curve, power)
        # Can verify that T commutes with deck group
        for g in G:
            assert T.matrix().transpose()*deck_group_actions[g] == deck_group_actions[g]*T.matrix().transpose()
        
        R = B.inverse()*T.matrix().transpose()*B
        # R will be a block matrix where each block is a multiple of the identity
        T_in_isotypic = matrix([[R[_sage_const_0 ][_sage_const_0 ], R[_sage_const_0 ][_sage_const_3 ]],[R[_sage_const_3 ][_sage_const_0 ],R[_sage_const_3 ][_sage_const_3 ]]])
        
        # Can verify that T has integer entries
        for i in range(_sage_const_0 ,_sage_const_2 ):
            for j in range(_sage_const_0 ,_sage_const_2 ):
                assert T_in_isotypic[i][j] in ZZ
        assert T_in_isotypic.determinant() == _sage_const_1 

        twist_matrices.append(T_in_isotypic)

##### Check finite index #####

print(is_finite_index(twist_matrices))

