

# This file was *autogenerated* from the file 3-r-2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7)#############################################################################
#
# In this file, we show that H_1(S) is 1 copy of M_2(Q) and 2 copies of a 1-dimensional irrep,
# and we show the action is arithmetic
#
#############################################################################

from surfaces import *
from lifted_twist import *
from index import *

import lifted_twist

G = DihedralGroup(_sage_const_4 )
r = G("(1,2,3,4)"); s = G("(1,4)(2,3)")
number_of_edges = _sage_const_8 
hom = [s,s,s,s,s*r,s*r,s*r**(-_sage_const_1 ),s*r**(-_sage_const_1 )]
gluing = {_sage_const_0 :_sage_const_1 , _sage_const_1 :_sage_const_0 , _sage_const_2 :_sage_const_3 , _sage_const_3 :_sage_const_2 , _sage_const_4 :_sage_const_5 , _sage_const_5 :_sage_const_4 , _sage_const_6 :_sage_const_7 , _sage_const_7 :_sage_const_6 }
edge_orientations = {_sage_const_0 :_sage_const_1 ,_sage_const_1 :-_sage_const_1 ,_sage_const_2 :_sage_const_1 ,_sage_const_3 :-_sage_const_1 ,_sage_const_4 :_sage_const_1 ,_sage_const_5 :-_sage_const_1 , _sage_const_6 :_sage_const_1 , _sage_const_7 :-_sage_const_1 }

base_surface = BaseSurface(number_of_edges, gluing, edge_orientations)
cover = Cover(base_surface, G, hom)

homology = HomologyGroup(cover)
deck_group_actions = {g:homology.action_of_deck_group_on_homology(g).matrix().transpose() for g in G}
# Sage assumes matrices act on the right, so we take the transpose to get an actual homomorphism
for g in G:
    for h in G:
        assert deck_group_actions[g]*deck_group_actions[h] == deck_group_actions[g*h]
assert homology.module.dimension() == _sage_const_6 


##### Building the irrep #####

rep = {r: matrix([[_sage_const_0 , -_sage_const_1 ], [_sage_const_1 , _sage_const_0 ]]), s: matrix([[_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ]])}
small_rep = {r: _sage_const_1 , s: -_sage_const_1 }
for i in range(_sage_const_0 , _sage_const_4 ):
    for j in range(_sage_const_0 ,_sage_const_2 ):
        rep[r**i*s**j] = rep[r]**i * rep[s]**j 
        small_rep[r**i*s**j] = small_rep[r]**i * small_rep[s]**j

for g in G:
    assert deck_group_actions[g].trace() == _sage_const_2 *rep[g].trace() + _sage_const_2 *small_rep[g]


##### Building the isomorphism between homology and rep #####

A = matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
assert A.determinant() != _sage_const_0 
B = zero_matrix(_sage_const_6 )

for g in G:
    g_bad = deck_group_actions[g]
    g_good = block_diagonal_matrix(rep[g], rep[g], small_rep[g]*identity_matrix(_sage_const_2 ))
    B = B + g_bad*A*(g_good.inverse())

# Checking that we indeed have an isomorphism
assert B.determinant() != _sage_const_0 
for g in G:
    g_bad = deck_group_actions[g]
    g_good = block_diagonal_matrix(rep[g], rep[g], small_rep[g]*identity_matrix(_sage_const_2 ))
    assert g_bad*B*(g_good.inverse()) == B


##### Lifting twists #####

twist_matrices = []

curves = liftable_curves(cover, _sage_const_1 )
curves.append(lifted_twist.Curve(cover,[(_sage_const_7 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_6 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_5 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_4 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_3 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_2 ,_sage_const_0 ,-_sage_const_1 )]))
curves.append(lifted_twist.Curve(cover,[(_sage_const_1 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_7 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_6 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_5 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_4 ,_sage_const_0 ,-_sage_const_1 )]))
curves.append(lifted_twist.Curve(cover,[(_sage_const_3 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_2 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_1 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_7 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_6 ,_sage_const_0 ,-_sage_const_1 )]))
curves.append(lifted_twist.Curve(cover,[(_sage_const_5 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_4 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_3 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_2 ,_sage_const_0 ,-_sage_const_1 ),(_sage_const_1 ,_sage_const_0 ,_sage_const_1 ),(_sage_const_0 ,_sage_const_0 ,-_sage_const_1 )]))

for curve in curves:
    T = action_of_twist_on_homology(cover, homology, curve, _sage_const_2 )
    # Can verify that T commutes with deck group
    for g in G:
        assert T.matrix().transpose()*deck_group_actions[g] == deck_group_actions[g]*T.matrix().transpose()
    
    R = B.inverse()*T.matrix().transpose()*B
    # The top-left 4x4 minor of R will be a block matrix where each block is a multiple of the identity
    T_in_isotypic = matrix([[R[_sage_const_0 ][_sage_const_0 ], R[_sage_const_0 ][_sage_const_2 ]],[R[_sage_const_2 ][_sage_const_0 ],R[_sage_const_2 ][_sage_const_2 ]]])
    
    # Can verify that T has integer entries
    for i in range(_sage_const_0 ,_sage_const_2 ):
        for j in range(_sage_const_0 ,_sage_const_2 ):
            assert T_in_isotypic[i][j] in ZZ
    assert T_in_isotypic.determinant() == _sage_const_1 

    twist_matrices.append(T_in_isotypic)


##### Check finite index #####

# Currently FALSE, need to return to this one
print(is_finite_index(twist_matrices))

